---
title: 'Chapter 3: Forward Propagation'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Prediction

A good rule of thumb is to provide as much input data as a human would need to a machine to make an accurate prediction. It is important to have a good interpretation of the shape of the data before constructing a nueral network. 

Case Study: Prediction of the likelihood that a baseball team will win. 
Say you wanted to create a simple neural network that takes only on input and output producing a prediction. 

Insert diagram below. 

# Simple Neural Net

**Python**

```{python, basic neural net}
# initial weight 
weight = 0.1 

# network 
def neural_network(input, weight):
    prediction = input * weight
    return prediction
    
numb_of_toes = [8.5, 9.5, 10, 9]

input = numb_of_toes[0]

pred = neural_network(input, weight)
print (pred)
```

**R**

```{r}
# initial weight 
weight_R <- 0.1

# network
neural_networkR <- function(input, weight_R)
{
  prediction <- input * weight_R
  return(prediction)
}

numb_of_toes <- c(8.5, 9.5, 10, 9)

input <- numb_of_toes[1]

pred <- neural_networkR(input, weight_R)

pred
```

**What our network is doing?**

Go back for more notes later.



**Making a prediction with multiple inputs** 




**Python** 


```{python}
def w_sum(a, b):
    assert(len(a) == len(b))
    output = 0
    for i in range(len(a)) :
      output += a[i] * b[i]
    return output
weights = [0.1, 0.2, 0]

def neural_network(input, weights):
    pred = w_sum(input, weights)
    return pred
toes = [8.5, 9.5, 9.9, 9.0]
wlrec = [0.65, 0.8, 0.8, 0.9]
nfans = [1.2, 1.3, 0.5, 1.0]

input = [toes[0], wlrec[0], nfans[0]]
pred = neural_network(input, weights)
print(pred)
```


**NumPY**

```{python}
import numpy as np
weights = np.array([0.1, 0.2, 0])

def neural_network(input, weights):
    pred = input.dot(weights)
    return pred
toes = np.array([8.5, 9.5, 9.9, 9.0])
wlrec = np.array([0.65, 0.8, 0.8, 0.9])
nfans = [1.2, 1.3, 0.5, 1.0]

input = np.array([toes[0], wlrec[0], nfans[0]])
pred = neural_network(input, weights)
pred


    

```






**R**

```{r}
weight_sum <- function(a, b)
{
  output <- 0 
  
  output <- a %*% b
  
  return(output)
}

wghts <- c(0.1, 0.2, 0)

neural_netR2 <- function(input, wghts)
{
  pred <- weight_sum(input, wghts)
  return(pred)
}
toes <- c(8.5, 9.5, 9.9, 9.0)
wlrec <- c(0.65, 0.8, 0.8, 0.9)
nfans <- c(1.2, 1.3, 0.5, 1.0)

input <- c(toes[1], wlrec[1], nfans[1])
pred <- neural_netR2(input, wghts)
pred
```

Go back to page 31 for discussion of dot product measuring similarity between vectors. 

**Making a Prediction with a single input and multiple outputs**

```{python}
weights = [0.3, 0.2, 0.9]

def ele_mult(scalar, vec):
    output = [0, 0, 0]
    assert( len(output) == len(vec))
    for i in range(len(vec)):
        output[i] = scalar * vec[i]
    return output

def neural_network(input, weights):
    pred = ele_mult(input, weights)
    return pred
wlrec = [0.65, 0.8, 0.8, 0.9]
input = wlrec[0]
pred = neural_network(input, weights)
print (pred)

```



**Predicting with multiple inputs and outputs **

```{python}
          # toes #ws #fans
weights = [[0.1, 0.1, -0.3], # hurt?
           [0.1, 0.2, 0.0],  # win? 
           [0.0, 1.3, 0.1]] # sad ?
           
def w_sum(a, b):
    assert(len(a) == len(b))
    output = 0
    for i in range(len(a)):
        output += (a[i] * b[i])
    return output
    
def vect_mat_mult(vector, matrix):
    assert(len(vector) == len(matrix))
    output = [0, 0, 0]
    for i in range(len(vector)):
        output[i] = w_sum(vector, matrix[i])
    return output
    


def neural_network(input, weights):

    pred = vect_mat_mult(input, weights)
    return pred

toes = [8.5, 9.5, 9.9, 9.0]
wlrec = [0.65, 0.8, 0.8, 0.9]
nfans = [1.2, 1.3, 0.5, 1.0]

input = [toes[0], wlrec[0], nfans[0]]

pred = neural_network(input, weights)

print (pred)

```
 


**Predicting on Predictions **

```{python}
          # toes % w  #fans
ih_wgt = [ [0.1, 0.2, -0.1], # hid[0]
           [-0.1, 0.1, 0.9], # hid[1]
           [0.1, 0.4, 0.1]] # hid[2]

hp_wgt = [ [0.3, 1.1, -0.3], # hurt? 
           [0.1, 0.2, 0.0], # win?
           [0.0, 1.3, 0.1]] # sad?
weights = [ih_wgt, hp_wgt]

def neural_network(input, weights):
    hid = vect_mat_mult(input, weights[0])
    pred = vect_mat_mult(hid, weights[1])
    return pred

def w_sum(a, b):
    assert(len(a) == len(b))
    output = 0
    for i in range(len(a)):
        output += (a[i] * b[i])
    return output
    
def vect_mat_mult(vector, matrix):
    assert(len(vector) == len(matrix))
    output = [0, 0, 0]
    for i in range(len(vector)):
        output[i] = w_sum(vector, matrix[i])
    return output

toes = [8.5, 9.5, 9.9, 9.0]
wlrec = [0.65, 0.8, 0.8, 0.9]
nfans = [1.2, 1.3, 0.5, 1.0]

input = [toes[0], wlrec[0], nfans[0]]

pred = neural_network(input, weights)

print (pred)
```

